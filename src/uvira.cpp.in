#include <iostream>
#include <range/v3/all.hpp>

#include <cfepi/modeling.hpp>
#include <cfepi/config.hpp>
#include <cfepi/sample_view.hpp>

namespace detail {
  /*
constexpr auto states_size = daw::json::parse_json_array_size<std::string_view>(
  daw::json::parse_json_select(json_config, "states"));
constexpr auto states_arr = daw::json::parse_json_array_values<std::string_view, states_size>(
  daw::json::parse_json_select(json_config, "states"));
constexpr cfepi::config_epidemic_states<states_size> states(states_arr);
constexpr auto num_event_types =
  daw::json::parse_json_array_size<daw::json::json_delayed<daw::json::no_name, std::string_view>>(
    daw::json::parse_json_select(json_config, "events"));
constexpr std::array<size_t, num_event_types> event_sizes =
  daw::json::parse_json_array_event_type_sizes<decltype(states), num_event_types>(
    daw::json::parse_json_select(json_config, "events"));
typedef daw::json::parse_json_array_event_type_struct<decltype(states), event_sizes>::any_event_type
  any_config_event_type;
typedef cfepi::any_event<any_config_event_type>::type any_config_event;
  */


}// namespace detail

using namespace detail;

int main() {

  const static constexpr std::string_view json_config = "@JSON_CONFIG_CONTENTS@";
  cfepi::run_simulation_from_config<json_config>();
  /*
  const cfepi::person_t population_size = static_cast<cfepi::person_t>(273613);
  double gamma = 1 / 2.25;
  if (argc > 2) { gamma = 1.0 / atof(argv[2]); }
  double beta = 1.05 * gamma / static_cast<double>(population_size);
  if (argc > 1) { beta = atof(argv[1]) * gamma / static_cast<double>(population_size); }
  cfepi::epidemic_time_t full_simulation_time{ 100 };
  if (argc > 3) {
    std::cout << argc << "\n";
    full_simulation_time = static_cast<cfepi::epidemic_time_t>(atof(argv[3]));
  }
  size_t seed{ 1 };
  if (argc > 4) { seed = static_cast<size_t>(atoi(argv[4])); }
  const cfepi::epidemic_time_t epidemic_time = full_simulation_time;
  std::random_device rd;
  std::default_random_engine random_source_1{ seed++ };

  auto vaccination_reduction =
    [](const auto &event, const auto &state, std::default_random_engine &rng) {
      std::uniform_real_distribution<> dist(0.0, 1.0);
      if (std::holds_alternative<std::variant_alternative_t<0, any_config_event>>(event)) {
        if (dist(rng) < 1) {
          cfepi::person_t this_person{ std::visit(
            cfepi::any_sir_event_get_affected_person<decltype(states)>{ 1 }, event) };
          return (!state.potential_states[this_person][states["V"]]);
        }
      }
      return (true);
    };
  constexpr cfepi::epidemic_time_t simulation_length{ 57 };
  std::array<cfepi::person_t, static_cast<size_t>(simulation_length + 1)> counts_to_filter_to{ 1,
    1,
    1,
    2,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    6,
    1,
    1,
    3,
    3,
    4,
    8,
    2,
    4,
    2,
    7,
    3,
    9,
    4,
    5,
    7,
    8,
    4,
    7,
    7,
    6,
    7,
    9,
    7,
    9,
    12,
    7,
    13,
    15,
    8,
    21,
    17,
    11,
    11,
    14,
    11,
    3,
    4,
    14,
    9,
    7,
    8 };
  const auto filter_by_infected =
    [&counts_to_filter_to](const cfepi::filtration_setup<decltype(states), any_config_event> &setup,
      const cfepi::sir_state<decltype(states)> &new_state,
      std::default_random_engine &rng __attribute__((unused))) {
      std::size_t this_time = static_cast<size_t>(new_state.time);
      if (this_time <= simulation_length) {
        auto incidence_counts =
          cfepi::aggregate_state(setup.states_entered).potential_state_counts[1 << states["I"]];
        if (incidence_counts < counts_to_filter_to[this_time]) {
          std::cout << "low ";
        } else {
          std::cout << "high ";
        }
        std::cout << incidence_counts << " modeled vs " << counts_to_filter_to[this_time]
                  << " expected\n";
        return (incidence_counts == counts_to_filter_to[this_time]);
      }
      return (true);
    };
  auto do_vaccination = [](double vaccination_percentage) {
    return ([vaccination_percentage](
              cfepi::sir_state<decltype(states)> &state, std::default_random_engine &rng) {
      std::cout << "Time is " << state.time << "\n";
      if (state.time > 0) { return; }
      std::cout << "VACCINATING at time " << state.time << "!\n";
      std::uniform_real_distribution<> dist(0.0, 1.0);
      for (auto &this_state : state.potential_states) {
        if (dist(rng) < vaccination_percentage) {
          this_state.set(states["V"], true);
          this_state.set(states["S"], false);
        }
      }
      return;
    });
  };
  auto always_true_state = [](const auto &setup __attribute__((unused)),
                             const auto &new_state __attribute__((unused)),
                             std::default_random_engine &rng
                             __attribute__((unused))) { return (true); };

  std::cout << "gamma is " << gamma << "\nbeta is " << beta << "\n";
  auto initial_conditions =
    cfepi::default_state<decltype(states)>(states["S"], states["I"], population_size, 1UL);

  constexpr auto event_type_tuple =
    daw::json::parse_json_array_event_type_struct<decltype(states), event_sizes>{}.parse(
      states, daw::json::parse_json_select(json_config, "events"));
  auto simulation =
    cfepi::run_simulation<decltype(states), any_config_event_type, any_config_event>(
      event_type_tuple,
      initial_conditions,
      std::array<double, 2>({ beta, gamma }),
      { std::make_tuple(vaccination_reduction, filter_by_infected, do_vaccination(.24)),
        std::make_tuple(vaccination_reduction, always_true_state, do_vaccination(.5)) },
      epidemic_time,
      seed);

  for (auto state_group : simulation) {
    size_t state_group_index{ 0 };
    for (auto state : state_group) {
      cfepi::print(state, "group " + std::to_string(state_group_index) + " : ");
      ++state_group_index;
    }
  }
  */
}
