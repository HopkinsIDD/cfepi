---
title: "Summary of What We Talked about Today"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

I wanted to make sure I understand what's going on, so here's my attempt to summarize what we talked about today, including the differences between what we were saying, how to convert between the different ways of thinking, and a brief discussion of the costs of each way.

## The model

I want to talk about this in view of a particular model.  I chose a SIR age-cohort model with 5 age categories.  All of the numbers are made up, so they may be wrong.  I don't think they matter for this particular discussion.

Here is a specification of the model:
```{r, echo=FALSE}
# SIR model with 5 age compartments
states <- c("S","I","R")
ages <- c("A1","A2","A3","A4","A5")
print("states")
print(states)
print("ages")
print(ages)
```
We need a probability of contacts being infectious (moving "S" to "I").
```{r, echo=FALSE}
# S -> I
beta = matrix(0,length(ages),length(ages))
rownames(beta) <- ages
colnames(beta) <- ages
names(dimnames(beta)) <- c("infector","infectee")
beta[1,] <- beta[1,] + .3
beta[2,] <- beta[2,] + .2
beta[3,] <- beta[3,] + .2
beta[4,] <- beta[4,] + .2
beta[5,] <- beta[5,] + .1
beta[,1] <- beta[,1] + .3
beta[,2] <- beta[,2] - .05
beta[,3] <- beta[,3] + .0
beta[,4] <- beta[,4] + .05
beta[,5] <- beta[,5] + .3
print("Infection")
print(beta)
```
This matrix accounts for some individuals being more infectious, and more susceptible based on their age.  We also need a probability of recovery (moving from "I" to "R").
```{r, echo=FALSE}
# I -> R
gamma = 1:length(ages)*0
names(gamma) <- ages
gamma[1] <- gamma[1] + .2
gamma[2] <- gamma[2] + .2
gamma[3] <- gamma[3] + .2
gamma[4] <- gamma[4] + .1
gamma[5] <- gamma[5] + .05
print("Recovery")
print(gamma)
```
This probability also depends on the age of the person in question.  Finally, we need a probability of changing age (changing from "Ai" to "Aj")
```{r, echo=FALSE}
# from one age to another
# diagonal should be 0
age_change <- matrix(0,length(ages),length(ages))
rownames(age_change) <- ages
colnames(age_change) <- ages
names(dimnames(age_change)) <- c("from","to")
age_change[1,2] <- .5
age_change[2,3] <- .1
age_change[3,4] <- .1
age_change[4,5] <- .1
print("Age Transition")
print(age_change)
```
In this case, we can only transition forward in age, but other models would potentially make use of the other non-diagonal entries.

The above represents my understanding of the way you were trying to think about the models.  If its wrong, let me know and no need to read further.

## Full Compartment Space

Below, I'll try to expand the model discussed above into the compartments currently used.  Note that currently, we do not deal with grouping, so everything will be done by compartment.  I'll try and expand the smaller matrices into a matrix and an array.  Both will be mostly $0$.

Based on the model, we should expect to see the following compartments.
```{r,echo=FALSE}
all_states <- apply(expand.grid(states,ages),1,paste,collapse='')
print(all_states)
```
We can construct a compartment transition matrix which does not depend on interactions.  In this case, we only need to know which compartment we're coming from, which compartment we're going to, and the probability of each.
```{r}
transition_matrix <- 
  matrix(
    0,
    length(all_states),
    length(all_states),
    dimnames = list(all_states,all_states)
  )
transition_matrix[
  startsWith(all_states,"I"),
  startsWith(all_states,"R")
] <- gamma
# This could be replaced with a loop over states
transition_matrix[
  startsWith(all_states,"S"),
  startsWith(all_states,"S")
] <- age_change
transition_matrix[
  startsWith(all_states,"I"),
  startsWith(all_states,"I")
] <- age_change
transition_matrix[
  startsWith(all_states,"R"),
  startsWith(all_states,"R")
] <- age_change
print(transition_matrix)
```

This matrix contains the information from `gamma` and `age_change`.  You can see that most of the entries are 0, and most of them are not useful for modeling.  We might want to do some kind of environmental resevoir by modeling "S" -> "I" here.  More probably, if we add more models, we would need another vector similar to `gamma` for each of their transitions.

We next construct a 3D array, which is extremely sparse.  It describes the probability of a person in category1 contacting a person in category2 and sending them to category3.  In our model, a person in category "SA2" could meet someone from category "IA1" and be sent to "IA2" for example.

```{r}
interaction_array = array(
  0,
  c(
    length(all_states),
    length(all_states),
    length(all_states)
  ),
  dimnames = list(
    from = all_states,
    meets = all_states,
    to = all_states
  )
)
```
Most of this matrix will be $0$, for example all rows and columns with an "R" category.  This array will house the `beta` matrix.  To see where the beta matrix belongs in this array, we consider.
```{r}
# Since we only use S -> I, beta should be in here:
tmparray <- interaction_array[
  startsWith(all_states,"S"),
  startsWith(all_states,"I"),
  startsWith(all_states,"I")
]
# Since we don't change age, then the from and to 
#   should have the same age category and so it
#   should also be in here
smaller_interaction_array <- apply(
  tmparray,
  2,
  diag
)
```
With a bit of reformatting, we can extract our beta matrix:
```{r}
dimnames(smaller_interaction_array)[[1]] <-
  c("S1->I1","S2->I2","S3->I3","S4->I4","S5->I5")
names(dimnames(smaller_interaction_array))[1] <-
  "Transition"
print(smaller_interaction_array)
```

```{r}
for(idx1 in 1:dim(tmparray)[1]){
  for(idx2 in 1:dim(tmparray)[2]){
    idx3 <- idx1 # This is for the diagonal
    dn1 <- dimnames(tmparray)[[1]][idx1]
    dn2 <- dimnames(tmparray)[[2]][idx2]
    dn3 <- dimnames(tmparray)[[3]][idx3]
    interaction_array[dn1,dn2,dn3] <- beta[idx1,idx2]
  }
}
```
If we perform the same calculations as before, we can see that `beta` is where it should be.
```{r}
smaller_interaction_array <- apply(
  interaction_array[startsWith(all_states,"S"),
                    startsWith(all_states,"I"),
                    startsWith(all_states,"I")
                    ],
  2,
  diag
)
all.equal(
  smaller_interaction_array,
  beta,
  check.attributes = FALSE
)
```

#### The c code's current state
The c code is currently not doing either of these, but using a modified version of the 3D array where it assumes that the the meet and to categories are always the same.  This is definitely wrong and needs to be changed, but its worth noting.

## Differences

#### Size
The main differences between the two models is the size.  The full state space model is:
```{r}
prod(dim(interaction_array)) +
  prod(dim(transition_matrix))
prod(dim(beta)) + prod(dim(age_change)) + length(gamma)
```
Even if we do a sparse representation, we have more in the full compartmental model
```{r}
sum(interaction_array > 0) + sum(transition_matrix > 0)
sum(beta > 0) + sum( age_change > 0) + sum(gamma > 0)
```
because elements of age_array are stored in multiple places.

While this could become a problem as the number of compartments gets large, this space is likely inconsequential compared to the way that disk space will skyrocket as we increase the number of models, assuming we use a sparse representation.  Using a dense representation, it doesn't start to matter until the number of compartments is $\sqrt{\text{population}}$.

Based on size, we should switch to using the grouped model, though it probably won't make much of a difference.

#### Simplicity

Each model is simple in its own way.  By specifying groups of things, the user can dramatically cut down on effort, especially if they are familiar with this kind of model already.

The full compartmental model is simple in the sense that it allows the c code to not need to deal with a variable number of matrices on input.  While R could pass the c code a list of matrices, it is simpler and clearer to deal with only one matrix and one array.

Without any performance concerns, it then makes sense to let people specify their models in grouped way, and convert them before passing them to c.

However, this only applies to the `gamma` and `age_construct` type terms.  If we assume that any infected-susceptible contact moves from susceptible to a particular associated infected, then we can eliminate the array altogether with relatively little pain.  This also allows us to drop keeping track of states, which reduces our disk space consumption. 

#### Flexibility

The grouped method is slightly less flexible, but not in a way that we care about.  This should not impact the decision to use one over the other.

## Resolution

#### Fix a susceptible group

Replace `interaction_array` with the following:

```{r}
state_transitions <- setNames(
  which(startsWith(all_states,"I")),
  which(startsWith(all_states,"S"))
)
beta <- beta
dimnames(beta) <- list(
  names(state_transitions),
  state_transitions
)
transition_matrix <- transition_matrix

```

##### Problem?
if an individual $x_i$ has different probabilities of infectious contact with an individual $x_j$ based on their different ages, $a_i$ and $a_j$, how do i record infection contingent on the $a_i$ and $a_j$, which are possibly affected by the intervention.

Age is not a good example here, but quarantine in location compartments, or vaccination status in measles could be a time where the intervention may alter your compartment, and you would need to know if the conditional infection still occurs.

##How to do Interventions